
> 🐭 Flutter in Action을 읽고, 나만의 방식으로 다시 정리해보고자 한다.


### PART1. 플러터와 다트
#### Chapter1. 플러터
- 플러터는 구글에서 만들어 오픈 소스로 공개한 모바일 SDK다
- 플러터는 하나의 코드 베이스로 안드로이드, IOS, macOS, Linux, Window, Web으로 배포할 수 있다 (2025년 기준)
- 플러터는 개발자가 도메인 기능에 집중할 수 있도록 렌더링 엔진, UI 컴포넌트, 테스트 프레임워크, 도구, 라우터 등 앱을 만드는 데 필요한 모든 기능을 제공하는 플랫폼이다.
- 플러터는 배우기 쉽고, 모든 코드가 오픈 되어 있어 세부적인 제어도 가능하다.
- 플러터는 자바스크립트 기반의 크로스 플랫폼과 달리 자바스크립트 브리지를 발생시키지 않는다. 웹뷰로 구현할때의 DOM 성능이슈도 존재하지 않는다. 자체 렌더링 엔진을 탑재하고 있어 네이티브와 바로 소통하며 화면의 모든 픽셀을 직접 제어한다.
- 플러터는 테스트가 용이하다
- 플러터는 작은 컴포넌트(위젯)를 조합해 모바일 UI를 만든다.
- 스타일, 애니메이션, 리스트, 텍스트, 버튼, 페이지 등 UI를 구성하는 모든 것이 위젯이다. (플러터의 APP객체도 위젯)
- 플러터는 작은 위젯을 조합하는 방법으로 커스텀 위젯을 만든다.
    ```dart
    // 상속 방법 🚫
    class AddToCartButton extends Button {} 

    // 조합 방법 🟢
    class AddToCartButton extends StatelessWidget {
        @overrid
        build() {
            return Center(
                child: Button(
                    child: Text('Add to Cart')
                )
            );
        }
    } 
    ```
- 위젯은 `build()`를 포함한 다양한 생명주기 메서드와 객체 맴버를 포함한다.
- 위젯은 `StateFulWidget`과 `StatelessWidget`이 있다.
- `StatelessWidget`은 정보를 저장하지 않는 위젯으로, 생명주기를 프레임워크가 관리한다. (제거, 리빌드 등)
- `StatelessWidget`도 정보가 변경되면 다시 그려진다. <!--정보를 저장하지는 않지만 정보를 가지고 있고 이 정보가 변경되면 리빌드됨-->
- `StatefulWidget`은 `State` 객체를 가지고 정보를 저장하며 `setState()` 함수를 호출하여 정보 변경 및 위젯을 다시 그려야함을 알린다.
    ```Dart
    Widget build(BuildContext context) {
        return IconButton(
            icon: Icons.add,
            onPressed: () {
                setState(() {
                    this.quntity++;
                });
            }
        )
    }
    ```
    <br><br>

###### StatefulWidget의 생명주기
 ![StatefulWidget의 생명주기](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzG45G%2Fbtrv45wNche%2FJJqA7K0w6FSRMAdnNCApY0%2Fimg.png)
 이미지 출처: [[flutter] 플러터 StatefulWidget 라이프 사이클 (lifecycle)](https://fronquarry.tistory.com/16)
1. 페이지로 이동하면 플러터가 객체를 만들고 이 객체는 위젯과 관련된 `State` 객체를 만든다.
2. 위젯이 마운트되면 플러터가 `initState`를 호출한다[^1].
3. 상태를 초기화하면 플러터가 위젯을 빌드한다. 그 결과 화면에 위젯을 그린다.
4. 위젯은 세가지 이벤트 중 하나를 기다린다.
    - 사용자가 앱의 다른화면으로 이동하면서 화면을 폐기(Dispose)한다
    - 트리의 다른 위젯이 갱신되면서 위젯이 의존하는 설정이 바뀜. 위젯의 상태는 `didUpdateWidget`을 호출하며 필요하다면 위젯을 다시 그림. 예를 들면 트리의 상위 위젯에서 해당 위젯의 버튼을 비활성화하는 경우
    - 사용자가 버튼을 눌러 `setState`를 호출해 위젯의 내부 상태가 갱신되어 플러터가 위젯을 다시 빌드하고 그리는 상황인 경우<br><br>

[^1]: 위젯이 마운트(Mount) 된다는 것은, Flutter에서 해당 위젯이 위젯 트리에 추가되어 렌더링 준비를 마쳤다는 것을 의미한다. 쉽게 말해, 화면에 나타나거나 나타날 준비가 된 상태.


###### 플러터 렌더링: 내부 동작 원리
- 플러터 위젯은 리액티브다. 즉 정보가 변경되면, 반응하고 필요하면 위젯을 다시 그린다.
    1. 사용자가 버튼을 누름
    2. Button.onPressed 콜백에서 setState를 호출함
    3. Button의 상태가 dirty로 바뀌었으므로 플러터는 이 위젯을 리빌드함
    4. 트리에서 기존 위젯을 새 위젯으로 바꿈
    5. 플러터가 새 트리를 그림
- 플러터의 전체적인 렌더링 과정
    1. __애니메이트__ : 애니메이션 티커(animation ticker) 타이머 시작
        요소가 변경되어야하는 시간을 애니메이션 티커가 제어
        애니메이션이 일어나는 동안 플러터는 프레임마다 위젯을 리빌드하고 그림
    2. __빌드__ : 플러터가 모든 위젯을 빌드하고 위젯 트리를 만듦
        화면에 나타날 요소(위젯)들을 결정
    3. __레이아웃__ : 플러터가 트리를 내려갔다가 _(제약 결정)_ 거슬러 올라오면서 _(크기 결정)_ 대상 위젯의 레이아웃을 결정함
        빌드한 위젯 트리를 아래로 탐색하면서 위젯의 _위치 정보/제약_ 를 수집 (부모 -> 자식)
        수집한 제약 정보를 바탕으로 자신의 _크기_ 를 계산하여 부모 위젯에 전달 (자식 -> 부모)
        수집한 제약정보와 크기정보로 최종 레이아웃 결정
    4. __조립__ : 각 픽셀 준비
        위젯에 실제 화면상의 좌표 제공, 실제 위젯이 화면상 차지하는 픽셀 수를 확인
        조립된 위젯과 그리기 과정을 분리하여 조립된 위젯을 재사용할 수 있다.
        ex) 리스트를 스크롤하는 경우, 리스트의 모든 항목을 다시 빌드할 필요 없이 플러터는 기존에 빌드하고 그렸던 위젯을 필요한 곳에 재사용
    5. __그리기__ : 플러터가 화면에 위젯을 그림 (래스터라이징)[^2]<br><br>

[^2]: 그래픽 엔진(Skia)을 통해, UI 요소들을 픽셀 단위의 래스터 이미지로 변환하여 화면에 표시


#### Chapter2. 다트
- 플러터는 다트 언어를 사용한다.
- 다트는 JIT[just-in-time] 컴파일과 AOT[ahead-of-time] 컴파일을 모두 지원하기 때문에 뛰어난 성능과 개발의 편의를 동시에 누릴 수 있다.
    * AOT 컴파일러 / 다트 코드를 효율적인 네이티브 코드로 바꿈, 빠르게 동작하고 전체 프레임워크를 거의 다트로 구현할 수 있기 때문에 거의 모든 것을 커스터마이즈할 수 있다.
    * 선택형 JIT 컴파일러 / 핫 리로드 지원, 빠른 개발 속도
- 다트는 객체지향 언어이며 단일 상속을 지원한다.
- 다트에서 모든 것은 객체이며, 객체는 클래스의 인스턴스다. 모든 객체는 Object 클래스를 상속받는다.
- 다트는 최상위 수준 함수와 변수를 지원하며 이를 라이브러리 멤버라 부른다.
- 다트는 생산성이 좋고 예측 가능한 언어다. 다른 고급 프로그래밍 언어들과 비슷
- 다트의 형식 시스템과 객체지향 덕분에 재사용할 수 있는 UI 컴포넌트를 쉽게 구현 가능
- 다트는 데이터를 UI로 편리하게 변환하도록 다양한 함수형 프로그래밍 기능도 지원
- 다트는 처음 웹 개발 언어로 만들어졌고, 다트 코드를 자바스크립트로 변환하는 컴파일러를 구현했다. 따라서 플러터의 웹 배포가 가능하다
- `print('Hello, ${name}')` 과 같은 형태를 채움(Interpolation) 기능이라 한다.
- final과 const는 모두 변수의 값을 바꿀 수 없게 하는데, const는 컴파일 이후로 항상 같은 값을 갖게하고 final은 클래스 수준에서 변수를 한번만 할당하고 변경할 수 없게 한다.
- 다트에서 함수도 객체이며 Function이라는 형식을 갖는다. 함수를 인수로 전달하거나 함수에서 함수로 반환할 수 있다.[^3]
- 물리적 물체뿐만 아니라 개념, 이벤트, 논리적 형용사의 그룹 등 모든 것이 사물이다. 모든 사물을 클래스로 만들 수 있다. 필자는 확신이 서지 않으면 새 클래스를 만드는 것을 규칙으로 한다. 
- 이벤트를 클래스로 만들면 다트의 형식을 더 효과적이고 안전하게 만든다. 
- 클래스를 정의할 때, 지나치게 구체적인 동작이나 사물을 묘사하는 이름을 피하고, 보다 일반적이고 포괄적인 이름을 사용하는 것이 좋다. ExchangeMoney(환전)보다는 Transaction(거래)라는 이름을 사용하는 것이 재사용성과 확장성에 유리하다.
    ```Dart
    class TransactionEvent {}
    ```
- 다트에서는 객체 생성시에 컴파일러가 자동으로 new나 const 키워드를 추론하기 때문에 해당 키워드들은 생략할 수 있다.
- 클래스 생성자에는 기본 생성자, factory 생성자(매번 새로운 인스턴스를 생성하지 않고 기존 인스턴스를 반환하거나, 서브클래스의 인스턴스를 반환), 지정 생성자(오버로딩 생성자)가 있다.
    ```Dart
    class Energy {
        int joules;

        // 기본 생성자
        Energy(this.joules);

        // 지정 생성자
        Energy.fromWind(int windBlows) {
            final joules = _convertWindToEnergy(windBlows);
            return Energy(joules);
        }

        // factory 생성자
        factory Energy.fromSolar(int sunbeams) {
            if (appState.solarEnergy != null) return appState.solarEnergy;
            final joules = _convertSunbeamsToJoules(sunbeams);
            return appState.solarEnergy = Energy(joules);
        }
    }
    ```
- 열거형 (enum)을 사용하면 간단하게 형식 안정성을 확보할 수 있다.<br><br>

[^3]: 이를 고차 함수(high-order function)라한다. 고차함수를 통해 추상화를 보다 쉽게 로직을 추상화 할 수 있다.
    

#### Chapter3. 플러터의 세계로
- 플러터의 기본 코드는 lib 디렉터리에 작성하며 main.dart의 main함수가 앱의 진입점이다. `void main() => runApp(MyApp())`
- 플러터의 모든 위젯은 다른 위젯을 반환하는 build 메서드를 포함한다.
- 위젯의 new, const 생성자는 생략가능하며, 프레임워크가 const를 우선하여 추론하고 추가하여 생성한다.<br><br>
- 플러터 UI를 개발한다는 것은 수많은 __위젯을 조합해 위젯트리를 완성함__ 을 의미한다.
    각 노드는 위젯이고 노드(위젯)가 모여 트리가 된다. buld 메서드에서 위젯을 추가할 때마다 트리에 새 노드를 추가한다. 각 노드는 부모와 자식 관계로 연결된다.
- StatelessWidget : 상태를 바꿀 수 없는 위젯, 정보(프로퍼티나, 크기 제약, 메타 정보등)를 전달할 수 있으나, 정적이며 직접 상태를 갱신하는 로직을 포함하지 않는다. 아무 데이터도 책임 지지 않기 때문에, 위젯의 리빌드는 프레임워크가 주관한다.
- StatefulWidget : 상태를 가지며, 이를 관리한다. StatefulWidget은 상태 객체를 가지며, 상태 객체는 변경할 수 있고 initState, setState, build 메서드를 포함한다. initState는 상태 객체를 만들때 한번 호출되며, setState를 호출하면 build 메서드를 실행하면서 정보가 바뀐 모든 위젯을 다시 그린다.
- setState는 비동기 코드를 실행할 수 없으며, setState 실행 전, 모든 비동기 코드를 완료해야한다.
- 다트의 비공개 값은 언더바로 지정하며 클래스의 언더파는 파일 단위의 비공개를 뜻하고 변수나 함수의 언더바는 클래스 멤버의 비공개를 뜻한다.</br></br>
- 위젯의 build 메서드는 `BuildContext`를 인수로 받는다. `BuildContext`는 위젯 트리에서 위젯의 위치를 참조한다. (위젯 자체 정보 X)
- `Theme.of`를 호출할 때 `BuildContext`를 인수로 전달하면 현재 위젯 트리의 테마(트리에서 형식이 같은 가장 가까운 부모)가 반환된다.
![BuildContext로 Theme 사용하기](https://drek4537l1klr.cloudfront.net/windmill/v-8/Figures/theme_of.png)</br></br>
- 플러터는 클래스 관계를 정의할 때 상속보다는 조합의 방식을 선호한다. 상속은 `is a`관계를 만들고 조합은 `has a`관계를 만든다.
    ```
    :: 상속 ::

    [인간] 
    - 말을 타다
        [카우보이 | 인간] 
        - 말을 타다. (상속)
        - 추격 하다.
        - 외계인과 싸우다.
        [목장주인 | 인간]
        - 말을 타다. (상속)
        - 말을 몰다.

    [외계인]
    - 말을 타다. // 인간이 아니라 상속할 수 없음
    - 우주선을 타다.

    ---

    :: 조합 ::
    [카우보이] = 말타기 + 추격하기 + 외계인과 싸우기
    [목장주인] = 말타기 + 말몰기
    [외계인] = 말타기 + 우주선타기

    ```
- 플러터 조합을 이용하기 때문에 부모는 자식이 무엇인지 몰라도 된다. 예를 들면 버튼의 경우 child로 텍스트가 올 수 도있고 아이콘이 올 수 도 있다. `텍스트는 버튼이다`가 아니라 `버튼은 텍스트를 가진다(가질수있다)`로 표현할  수 있다. 플러터는 다양한 레이아웃 시스템을 조합하여 레이아웃을 만들 수 있다.</br></br>

__RenderObject와 제약 조건__
- 다시 정리하기
- RenderObject는 실제 화면에 그리는 작업을 담당한다. 렌더 객체가 모여 렌더 트리를 만든다. 렌더 객체는 각자 대응하는 위젯을 갖는다. 렌더 객체는 제약 조건과 같은 데이터를 가질 수 있다. 렌더 객체는 performLayout.paint 등의 메서드로 화면의 픽셀을 그린다. 렌더 객체는 상태나 로직을 포함하지 않는다. Column 등 컨테이너는 오젝 제약 조건을 제공하는 역할만 담당한다. 
    > __Flutter layout infinite size issue__  </br> Row, Column, 스크롤할 수 있는 위젯에서 unbounded 제약 조건을 사용할 때 이론적으로 무한의 사이즈를 가질 수 있는데, 실제 컴퓨터는 연산 능력과 메모리가 무한하기때문에 에러가 발생 > 무한의 사이즈를 가질 수 있는 경우에는 한정적인 제약 조건을 설정해야한다. 

</br>

__요소 트리__

위젯트리 / 요소트리 / 렌더트리
- 요소를 설정하면 위젯이 된다. 실제 트리에 존재하고 마운트되는 위젯이 요소.
- Element는 RenderObject도 포함한다. 렌더 객체는 실제 화면에 그리는 작업을 수행하기때문에 복잡하고 비용이 많이 든다. 이때문에 렌더 객체를 재사용하고 위젯의 생명주기를 편하게 관리하기위해 세개의 위젯트리를 관리한다.
- 위젯은 `Widget.createElement(this)`로 요소를 만든다. 이때 요소는 위젯의 참조를 갖게된다. 요소 트리는 앱의 골격이고 세부적인 내용은 위젯의 참조를 통해 파악한다.
- 요소는 위젯과 달리 다시 빌드되지않고 위젯에 대한 참조를 갱신하여 정보의 변경을 앱에 반영한다. 애니메이션의 경우에도 위젯은 매 프레임마다 다시 빌드되지만 요소는 위젯의 참조만을 수정한다. 때문에 플러터는 좋은 성능을 유지할 수 있다.
- 요소는 상태 객체를 관리한다. 플러터는 요소와 상태 객체를 이용해 렌더링을 진행한다. 상태 객체는 위젯보다 오래 살고 재사용 될 수 있다.
- 요소는 메타 정보와 위젯 참조를 포함하지만 위젯이 바뀌었을 때 레퍼런스를 갱신하는 방법을 모른다. 때문에 키를 이용하여 형식이 같은 두 위젯이 실제로는 다른 위젯임을 알려야한다.
- 키에는 로컬키와 글로벌키가 있다.


</br></br></br>

### PART2. 사용자 상호작용과 스타일, 애니메이션
#### Chapter4. 플러터 UI: 주요 위젯, 테마, 레이아웃
#### Chapter5. 사용자 입력: 폼과 제스처
#### Chapter6. 픽셀 제어: 플러터 애니메이션과 캔버스 사용하기


</br></br></br>

### PART3. 상태 관리와 비동기 작업
#### Chapter7. 플러터 라우팅
#### Chapter8. 상태 관리
#### Chapter9. 비동기 다트와 플러터 그리고 무한 스크롤


</br></br></br>

### PART4. 기초를 넘어
#### Chapter10. 데이터 처리: HTTP, 파이어스토어, JSON
#### Chapter11. 플러터 앱 테스트


</br></br></br>

### PART5. 부록

### PART6. 단어장
1. 프로퍼티 : 클래스나 위젯의 속성
2. 최상위 수준 변수
3. 정적 메서드
4. 전역 변수
5. 고차함수
6. 지정 생성자
7. 컴포넌트